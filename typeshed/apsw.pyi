import array
import mmap
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import List
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import Sequence
from typing import Set
from typing import TextIO
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union

_ReadableBuffer = Union[bytes, bytearray, memoryview, array.array, mmap.mmap]
_WriteableBuffer = Union[bytearray, memoryview, array.array, mmap.mmap]

SQLITE_ABORT: int
SQLITE_ABORT_ROLLBACK: int
SQLITE_ACCESS_EXISTS: int
SQLITE_ACCESS_READ: int
SQLITE_ACCESS_READWRITE: int
SQLITE_ALTER_TABLE: int
SQLITE_ANALYZE: int
SQLITE_ATTACH: int
SQLITE_AUTH: int
SQLITE_AUTH_USER: int
SQLITE_BUSY: int
SQLITE_BUSY_RECOVERY: int
SQLITE_BUSY_SNAPSHOT: int
SQLITE_CANTOPEN: int
SQLITE_CANTOPEN_CONVPATH: int
SQLITE_CANTOPEN_DIRTYWAL: int
SQLITE_CANTOPEN_FULLPATH: int
SQLITE_CANTOPEN_ISDIR: int
SQLITE_CANTOPEN_NOTEMPDIR: int
SQLITE_CANTOPEN_SYMLINK: int
SQLITE_CHECKPOINT_FULL: int
SQLITE_CHECKPOINT_PASSIVE: int
SQLITE_CHECKPOINT_RESTART: int
SQLITE_CHECKPOINT_TRUNCATE: int
SQLITE_CONFIG_COVERING_INDEX_SCAN: int
SQLITE_CONFIG_GETMALLOC: int
SQLITE_CONFIG_GETMUTEX: int
SQLITE_CONFIG_GETPCACHE: int
SQLITE_CONFIG_GETPCACHE2: int
SQLITE_CONFIG_HEAP: int
SQLITE_CONFIG_LOG: int
SQLITE_CONFIG_LOOKASIDE: int
SQLITE_CONFIG_MALLOC: int
SQLITE_CONFIG_MEMDB_MAXSIZE: int
SQLITE_CONFIG_MEMSTATUS: int
SQLITE_CONFIG_MMAP_SIZE: int
SQLITE_CONFIG_MULTITHREAD: int
SQLITE_CONFIG_MUTEX: int
SQLITE_CONFIG_PAGECACHE: int
SQLITE_CONFIG_PCACHE: int
SQLITE_CONFIG_PCACHE2: int
SQLITE_CONFIG_PCACHE_HDRSZ: int
SQLITE_CONFIG_PMASZ: int
SQLITE_CONFIG_SCRATCH: int
SQLITE_CONFIG_SERIALIZED: int
SQLITE_CONFIG_SINGLETHREAD: int
SQLITE_CONFIG_SMALL_MALLOC: int
SQLITE_CONFIG_SORTERREF_SIZE: int
SQLITE_CONFIG_SQLLOG: int
SQLITE_CONFIG_STMTJRNL_SPILL: int
SQLITE_CONFIG_URI: int
SQLITE_CONFIG_WIN32_HEAPSIZE: int
SQLITE_CONSTRAINT: int
SQLITE_CONSTRAINT_CHECK: int
SQLITE_CONSTRAINT_COMMITHOOK: int
SQLITE_CONSTRAINT_FOREIGNKEY: int
SQLITE_CONSTRAINT_FUNCTION: int
SQLITE_CONSTRAINT_NOTNULL: int
SQLITE_CONSTRAINT_PINNED: int
SQLITE_CONSTRAINT_PRIMARYKEY: int
SQLITE_CONSTRAINT_ROWID: int
SQLITE_CONSTRAINT_TRIGGER: int
SQLITE_CONSTRAINT_UNIQUE: int
SQLITE_CONSTRAINT_VTAB: int
SQLITE_COPY: int
SQLITE_CORRUPT: int
SQLITE_CORRUPT_SEQUENCE: int
SQLITE_CORRUPT_VTAB: int
SQLITE_CREATE_INDEX: int
SQLITE_CREATE_TABLE: int
SQLITE_CREATE_TEMP_INDEX: int
SQLITE_CREATE_TEMP_TABLE: int
SQLITE_CREATE_TEMP_TRIGGER: int
SQLITE_CREATE_TEMP_VIEW: int
SQLITE_CREATE_TRIGGER: int
SQLITE_CREATE_VIEW: int
SQLITE_CREATE_VTABLE: int
SQLITE_DBCONFIG_DEFENSIVE: int
SQLITE_DBCONFIG_DQS_DDL: int
SQLITE_DBCONFIG_DQS_DML: int
SQLITE_DBCONFIG_ENABLE_FKEY: int
SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER: int
SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION: int
SQLITE_DBCONFIG_ENABLE_QPSG: int
SQLITE_DBCONFIG_ENABLE_TRIGGER: int
SQLITE_DBCONFIG_ENABLE_VIEW: int
SQLITE_DBCONFIG_LEGACY_ALTER_TABLE: int
SQLITE_DBCONFIG_LEGACY_FILE_FORMAT: int
SQLITE_DBCONFIG_LOOKASIDE: int
SQLITE_DBCONFIG_MAINDBNAME: int
SQLITE_DBCONFIG_MAX: int
SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE: int
SQLITE_DBCONFIG_RESET_DATABASE: int
SQLITE_DBCONFIG_TRIGGER_EQP: int
SQLITE_DBCONFIG_TRUSTED_SCHEMA: int
SQLITE_DBCONFIG_WRITABLE_SCHEMA: int
SQLITE_DBSTATUS_CACHE_HIT: int
SQLITE_DBSTATUS_CACHE_MISS: int
SQLITE_DBSTATUS_CACHE_SPILL: int
SQLITE_DBSTATUS_CACHE_USED: int
SQLITE_DBSTATUS_CACHE_USED_SHARED: int
SQLITE_DBSTATUS_CACHE_WRITE: int
SQLITE_DBSTATUS_DEFERRED_FKS: int
SQLITE_DBSTATUS_LOOKASIDE_HIT: int
SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: int
SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE: int
SQLITE_DBSTATUS_LOOKASIDE_USED: int
SQLITE_DBSTATUS_MAX: int
SQLITE_DBSTATUS_SCHEMA_USED: int
SQLITE_DBSTATUS_STMT_USED: int
SQLITE_DELETE: int
SQLITE_DENY: int
SQLITE_DETACH: int
SQLITE_DONE: int
SQLITE_DROP_INDEX: int
SQLITE_DROP_TABLE: int
SQLITE_DROP_TEMP_INDEX: int
SQLITE_DROP_TEMP_TABLE: int
SQLITE_DROP_TEMP_TRIGGER: int
SQLITE_DROP_TEMP_VIEW: int
SQLITE_DROP_TRIGGER: int
SQLITE_DROP_VIEW: int
SQLITE_DROP_VTABLE: int
SQLITE_EMPTY: int
SQLITE_ERROR: int
SQLITE_ERROR_MISSING_COLLSEQ: int
SQLITE_ERROR_RETRY: int
SQLITE_ERROR_SNAPSHOT: int
SQLITE_FAIL: int
SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: int
SQLITE_FCNTL_BUSYHANDLER: int
SQLITE_FCNTL_CHUNK_SIZE: int
SQLITE_FCNTL_CKPT_DONE: int
SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: int
SQLITE_FCNTL_COMMIT_PHASETWO: int
SQLITE_FCNTL_DATA_VERSION: int
SQLITE_FCNTL_FILE_POINTER: int
SQLITE_FCNTL_GET_LOCKPROXYFILE: int
SQLITE_FCNTL_HAS_MOVED: int
SQLITE_FCNTL_JOURNAL_POINTER: int
SQLITE_FCNTL_LAST_ERRNO: int
SQLITE_FCNTL_LOCKSTATE: int
SQLITE_FCNTL_LOCK_TIMEOUT: int
SQLITE_FCNTL_MMAP_SIZE: int
SQLITE_FCNTL_OVERWRITE: int
SQLITE_FCNTL_PDB: int
SQLITE_FCNTL_PERSIST_WAL: int
SQLITE_FCNTL_POWERSAFE_OVERWRITE: int
SQLITE_FCNTL_PRAGMA: int
SQLITE_FCNTL_RBU: int
SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: int
SQLITE_FCNTL_SET_LOCKPROXYFILE: int
SQLITE_FCNTL_SIZE_HINT: int
SQLITE_FCNTL_SIZE_LIMIT: int
SQLITE_FCNTL_SYNC: int
SQLITE_FCNTL_SYNC_OMITTED: int
SQLITE_FCNTL_TEMPFILENAME: int
SQLITE_FCNTL_TRACE: int
SQLITE_FCNTL_VFSNAME: int
SQLITE_FCNTL_VFS_POINTER: int
SQLITE_FCNTL_WAL_BLOCK: int
SQLITE_FCNTL_WIN32_AV_RETRY: int
SQLITE_FCNTL_WIN32_GET_HANDLE: int
SQLITE_FCNTL_WIN32_SET_HANDLE: int
SQLITE_FCNTL_ZIPVFS: int
SQLITE_FORMAT: int
SQLITE_FULL: int
SQLITE_FUNCTION: int
SQLITE_IGNORE: int
SQLITE_INDEX_CONSTRAINT_EQ: int
SQLITE_INDEX_CONSTRAINT_FUNCTION: int
SQLITE_INDEX_CONSTRAINT_GE: int
SQLITE_INDEX_CONSTRAINT_GLOB: int
SQLITE_INDEX_CONSTRAINT_GT: int
SQLITE_INDEX_CONSTRAINT_IS: int
SQLITE_INDEX_CONSTRAINT_ISNOT: int
SQLITE_INDEX_CONSTRAINT_ISNOTNULL: int
SQLITE_INDEX_CONSTRAINT_ISNULL: int
SQLITE_INDEX_CONSTRAINT_LE: int
SQLITE_INDEX_CONSTRAINT_LIKE: int
SQLITE_INDEX_CONSTRAINT_LT: int
SQLITE_INDEX_CONSTRAINT_MATCH: int
SQLITE_INDEX_CONSTRAINT_NE: int
SQLITE_INDEX_CONSTRAINT_REGEXP: int
SQLITE_INDEX_SCAN_UNIQUE: int
SQLITE_INSERT: int
SQLITE_INTERNAL: int
SQLITE_INTERRUPT: int
SQLITE_IOCAP_ATOMIC: int
SQLITE_IOCAP_ATOMIC16K: int
SQLITE_IOCAP_ATOMIC1K: int
SQLITE_IOCAP_ATOMIC2K: int
SQLITE_IOCAP_ATOMIC32K: int
SQLITE_IOCAP_ATOMIC4K: int
SQLITE_IOCAP_ATOMIC512: int
SQLITE_IOCAP_ATOMIC64K: int
SQLITE_IOCAP_ATOMIC8K: int
SQLITE_IOCAP_BATCH_ATOMIC: int
SQLITE_IOCAP_IMMUTABLE: int
SQLITE_IOCAP_POWERSAFE_OVERWRITE: int
SQLITE_IOCAP_SAFE_APPEND: int
SQLITE_IOCAP_SEQUENTIAL: int
SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: int
SQLITE_IOERR: int
SQLITE_IOERR_ACCESS: int
SQLITE_IOERR_AUTH: int
SQLITE_IOERR_BEGIN_ATOMIC: int
SQLITE_IOERR_BLOCKED: int
SQLITE_IOERR_CHECKRESERVEDLOCK: int
SQLITE_IOERR_CLOSE: int
SQLITE_IOERR_COMMIT_ATOMIC: int
SQLITE_IOERR_CONVPATH: int
SQLITE_IOERR_DELETE: int
SQLITE_IOERR_DELETE_NOENT: int
SQLITE_IOERR_DIR_CLOSE: int
SQLITE_IOERR_DIR_FSYNC: int
SQLITE_IOERR_FSTAT: int
SQLITE_IOERR_FSYNC: int
SQLITE_IOERR_GETTEMPPATH: int
SQLITE_IOERR_LOCK: int
SQLITE_IOERR_MMAP: int
SQLITE_IOERR_NOMEM: int
SQLITE_IOERR_RDLOCK: int
SQLITE_IOERR_READ: int
SQLITE_IOERR_ROLLBACK_ATOMIC: int
SQLITE_IOERR_SEEK: int
SQLITE_IOERR_SHMLOCK: int
SQLITE_IOERR_SHMMAP: int
SQLITE_IOERR_SHMOPEN: int
SQLITE_IOERR_SHMSIZE: int
SQLITE_IOERR_SHORT_READ: int
SQLITE_IOERR_TRUNCATE: int
SQLITE_IOERR_UNLOCK: int
SQLITE_IOERR_VNODE: int
SQLITE_IOERR_WRITE: int
SQLITE_LIMIT_ATTACHED: int
SQLITE_LIMIT_COLUMN: int
SQLITE_LIMIT_COMPOUND_SELECT: int
SQLITE_LIMIT_EXPR_DEPTH: int
SQLITE_LIMIT_FUNCTION_ARG: int
SQLITE_LIMIT_LENGTH: int
SQLITE_LIMIT_LIKE_PATTERN_LENGTH: int
SQLITE_LIMIT_SQL_LENGTH: int
SQLITE_LIMIT_TRIGGER_DEPTH: int
SQLITE_LIMIT_VARIABLE_NUMBER: int
SQLITE_LIMIT_VDBE_OP: int
SQLITE_LIMIT_WORKER_THREADS: int
SQLITE_LOCKED: int
SQLITE_LOCKED_SHAREDCACHE: int
SQLITE_LOCKED_VTAB: int
SQLITE_LOCK_EXCLUSIVE: int
SQLITE_LOCK_NONE: int
SQLITE_LOCK_PENDING: int
SQLITE_LOCK_RESERVED: int
SQLITE_LOCK_SHARED: int
SQLITE_MISMATCH: int
SQLITE_MISUSE: int
SQLITE_NOLFS: int
SQLITE_NOMEM: int
SQLITE_NOTADB: int
SQLITE_NOTFOUND: int
SQLITE_NOTICE: int
SQLITE_NOTICE_RECOVER_ROLLBACK: int
SQLITE_NOTICE_RECOVER_WAL: int
SQLITE_OK: int
SQLITE_OK_LOAD_PERMANENTLY: int
SQLITE_OK_SYMLINK: int
SQLITE_OPEN_AUTOPROXY: int
SQLITE_OPEN_CREATE: int
SQLITE_OPEN_DELETEONCLOSE: int
SQLITE_OPEN_EXCLUSIVE: int
SQLITE_OPEN_FULLMUTEX: int
SQLITE_OPEN_MAIN_DB: int
SQLITE_OPEN_MAIN_JOURNAL: int
SQLITE_OPEN_MASTER_JOURNAL: int
SQLITE_OPEN_MEMORY: int
SQLITE_OPEN_NOFOLLOW: int
SQLITE_OPEN_NOMUTEX: int
SQLITE_OPEN_PRIVATECACHE: int
SQLITE_OPEN_READONLY: int
SQLITE_OPEN_READWRITE: int
SQLITE_OPEN_SHAREDCACHE: int
SQLITE_OPEN_SUBJOURNAL: int
SQLITE_OPEN_TEMP_DB: int
SQLITE_OPEN_TEMP_JOURNAL: int
SQLITE_OPEN_TRANSIENT_DB: int
SQLITE_OPEN_URI: int
SQLITE_OPEN_WAL: int
SQLITE_PERM: int
SQLITE_PRAGMA: int
SQLITE_PROTOCOL: int
SQLITE_RANGE: int
SQLITE_READ: int
SQLITE_READONLY: int
SQLITE_READONLY_CANTINIT: int
SQLITE_READONLY_CANTLOCK: int
SQLITE_READONLY_DBMOVED: int
SQLITE_READONLY_DIRECTORY: int
SQLITE_READONLY_RECOVERY: int
SQLITE_READONLY_ROLLBACK: int
SQLITE_RECURSIVE: int
SQLITE_REINDEX: int
SQLITE_REPLACE: int
SQLITE_ROLLBACK: int
SQLITE_ROW: int
SQLITE_SAVEPOINT: int
SQLITE_SCHEMA: int
SQLITE_SELECT: int
SQLITE_SHM_EXCLUSIVE: int
SQLITE_SHM_LOCK: int
SQLITE_SHM_SHARED: int
SQLITE_SHM_UNLOCK: int
SQLITE_STATUS_MALLOC_COUNT: int
SQLITE_STATUS_MALLOC_SIZE: int
SQLITE_STATUS_MEMORY_USED: int
SQLITE_STATUS_PAGECACHE_OVERFLOW: int
SQLITE_STATUS_PAGECACHE_SIZE: int
SQLITE_STATUS_PAGECACHE_USED: int
SQLITE_STATUS_PARSER_STACK: int
SQLITE_STATUS_SCRATCH_OVERFLOW: int
SQLITE_STATUS_SCRATCH_SIZE: int
SQLITE_STATUS_SCRATCH_USED: int
SQLITE_SYNC_DATAONLY: int
SQLITE_SYNC_FULL: int
SQLITE_SYNC_NORMAL: int
SQLITE_TOOBIG: int
SQLITE_TRANSACTION: int
SQLITE_UPDATE: int
SQLITE_VERSION_NUMBER: int
SQLITE_VTAB_CONSTRAINT_SUPPORT: int
SQLITE_VTAB_DIRECTONLY: int
SQLITE_VTAB_INNOCUOUS: int
SQLITE_WARNING: int
SQLITE_WARNING_AUTOINDEX: int
compile_options: Tuple[str]
connection_hooks: List[Callable[[Connection], None]]
keywords: Set[str]
mapping_access: Any
mapping_authorizer_function: Any
mapping_authorizer_return: Any
mapping_bestindex_constraints: Any
mapping_config: Any
mapping_conflict_resolution_modes: Any
mapping_db_config: Any
mapping_db_status: Any
mapping_device_characteristics: Any
mapping_extended_result_codes: Any
mapping_file_control: Any
mapping_limits: Any
mapping_locking_level: Any
mapping_open_flags: Any
mapping_result_codes: Any
mapping_status: Any
mapping_sync: Any
mapping_virtual_table_configuration_options: Any
mapping_virtual_table_scan_flags: Any
mapping_wal_checkpoint: Any
mapping_xshmlock_flags: Any
using_amalgamation: bool

def apswversion() -> str: ...
def complete(stmt:str) -> bool: ...
def config(op:int, *args:Any) -> None: ...
def enablesharedcache(enable:bool) -> None: ...
def exceptionfor(code:int) -> Error: ...
def fork_checker() -> None: ...
def format_sql_value(value:Union[float, bytes, str, int]) -> str: ...
def initialize() -> None: ...
def log(level:int, msg:str) -> None: ...
def main() -> NoReturn: ...
def memoryhighwater(reset:bool=...) -> int: ...
def memoryused() -> int: ...
def randomness(n:int) -> bytes: ...
def releasememory(n:int) -> int: ...
def shutdown() -> None: ...
def softheaplimit(n:int) -> int: ...
def sqlite3_sourceid() -> str: ...
def sqlitelibversion() -> str: ...
def status(op:int, reset:bool=...) -> Tuple[int, int]: ...
def vfsnames() -> List[str]: ...

class AbortError(Error): ...

class AuthError(Error): ...

class BindingsError(Error): ...

class BusyError(Error): ...

class CantOpenError(Error): ...

_T = TypeVar("_T")
_Tracer = Callable[[Cursor, str, _Bindings], Any]

class Connection:
    filename: str
    open_flags: int
    open_vfs: str
    def __init__(self, filename:str, flags:int=..., vfs:str=...,
            statementcachesize:int=...) -> None: ...
    def backup(self, databasename:str, sourceconnection:Connection,
            sourcedatabasename:str) -> backup: ...
    def blobopen(self, database:str, table:str, column:str, rowid:int,
            writeable:bool) -> blob: ...
    def changes(self) -> int: ...
    def close(self, force:bool=...) -> None: ...
    def collationneeded(self, callable:Callable[[Connection, str], None]) -> None: ...
    def config(self, op: int, *args:Any) -> int: ...
    def createaggregatefunction(self, name:str, factory:Callable[...,
        Tuple[_T, Callable, Callable[[_T], None]]], numargs:int=...) -> None: ...
    def createcollation(self, name:str, callback:Callable[[Any, Any], int]) -> None: ...
    def createmodule(self, name:str, datasource:Any) -> None: ...
    def createscalarfunction(self, name:str,
            callable:Callable, numargs:int=..., deterministic:bool=...) -> None: ...
    def cursor(self) -> Cursor: ...
    def db_filename(self, name:str) -> str: ...
    def enableloadextension(self, enable:bool) -> None: ...
    def filecontrol(self, dbname:str, op:int, pointer:int) -> bool: ...
    def getautocommit(self) -> bool: ...
    def getexectrace(self) -> Optional[_Tracer]: ...
    def getrowtrace(self) -> Optional[_Tracer]: ...
    def interrupt(self) -> None: ...
    def last_insert_rowid(self) -> int: ...
    def limit(self, id:int, newval:int=...) -> int: ...
    def loadextension(self, filename:str, entrypoint:Optional[str]=...) -> None: ...
    def overloadfunction(self, name:str, nargs:int) -> None: ...
    def readonly(self, name:str) -> bool: ...
    def set_last_insert_rowid(self, rowid:int) -> None: ...
    def setauthorizer(self, callable:Optional[Callable[[int, Optional[str],
        Optional[str], Optional[str], Optional[str]], int]]) -> None: ...
    def setbusyhandler(self, callable:Optional[Callable[[int], bool]]) -> None: ...
    def setbusytimeout(self, milliseconds:int) -> None: ...
    def setcommithook(self, callable:Optional[Callable[[], int]]) -> None: ...
    def setexectrace(self, callable:Optional[_Tracer]) -> None: ...
    def setprofile(self, callable:Optional[Callable[[str, int], None]]) -> None: ...
    def setprogresshandler(self, callable:Optional[Callable[[], int]],
            nsteps:int=...) -> None: ...
    def setrollbackhook(self, callable:Optional[Callable[[], None]]) -> None: ...
    def setrowtrace(self, callable:Optional[_Tracer]) -> None: ...
    def setupdatehook(self, callable:Optional[Callable[[int, str, str, int], None]]) -> None: ...
    def setwalhook(self, callable:Optional[Callable[[Connection, str, int],
        int]]) -> None: ...
    def sqlite3pointer(self) -> int: ...
    def status(self, op:int, reset:bool=...) -> Tuple[int, int]: ...
    def totalchanges(self) -> int: ...
    def wal_autocheckpoint(self, n:int) -> None: ...
    def wal_checkpoint(self, dbname:Optional[str]=..., mode:int=...) -> Tuple[int, int]: ...
    def __enter__(self) -> Connection: ...
    def __exit__(self, type:Optional[Type[BaseException]],
            value:Optional[BaseException], traceback:Any) -> bool: ...

# Restricting the binding type got really complicated. In particular, TypedDict
# is Mapping[str, object] and can't be restricted by ancestors from typing, so
# we can't pass a TypedDict as a binding set.
#_Binding = Union[None, int, float, str, bytes, bool, _ReadableBuffer]
_Binding = Any
# Strictly, we should use Dict over Mapping, because apsw uses PyDict_Check.
# However Mapping seems to be the typing-kosher way to specify that the
# parameter is read-only, and is compatible with TypedDict.
_Bindings = Union[Sequence[_Binding], Mapping[str, _Binding]]
# Not sure there's any point to restricting the result types.
#_Result = Union[None, int, float, str, bytes]
_Result = Any

# not exposed
class Cursor:
    def close(self, force:bool=...) -> None: ...
    description: Tuple
    def execute(self, statements:str, bindings:_Bindings=...) -> Cursor:...
    def __iter__(self) -> Cursor: ...
    def __next__(self) -> Tuple[_Result, ...]: ...
    def executemany(self, statements:str, bindings:Iterable[_Bindings]) -> Cursor: ...
    def fetchall(self) -> List[Tuple[_Result, ...]]: ...
    def fetchone(self) -> Optional[Tuple[_Result, ...]]: ...
    def getconnection(self) -> Connection: ...
    def getdescription(self) -> Tuple[Tuple[str, str], ...]: ...
    def getexectrace(self) -> Optional[_Tracer]: ...
    def getrowtrace(self) -> Optional[_Tracer]: ...
    def setexectrace(self, callable:Optional[_Tracer]) -> None: ...
    def setrowtrace(self, callable:Optional[_Tracer]) -> None: ...

class ConnectionClosedError(Error): ...

class ConnectionNotClosedError(Error): ...

class ConstraintError(Error): ...

class CorruptError(Error): ...

class CursorClosedError(Error): ...

class EmptyError(Error): ...

class Error(Exception): ...

class ExecTraceAbort(Error): ...

class ExecutionCompleteError(Error): ...

class ExtensionLoadingError(Error): ...

class ForkingViolationError(Error): ...

class FormatError(Error): ...

class FullError(Error): ...

class IOError(Error): ...

class IncompleteExecutionError(Error): ...

class InternalError(Error): ...

class InterruptError(Error): ...

class LockedError(Error): ...

class MismatchError(Error): ...

class MisuseError(Error): ...

class NoLFSError(Error): ...

class NoMemError(Error): ...

class NotADBError(Error): ...

class NotFoundError(Error): ...

class PermissionsError(Error): ...

class ProtocolError(Error): ...

class RangeError(Error): ...

class ReadOnlyError(Error): ...

class SQLError(Error): ...

class SchemaChangeError(Error): ...

class Shell:
    def __init__(self, stdin:Optional[TextIO]=...,
            stdout:Optional[TextIO]=..., stderr:Optional[TextIO]=...,
            encoding:str=..., args:Optional[Sequence[str]]=...,
            db:Optional[Connection]=...) -> None: ...
    Error: Type[Exception]
    def cmdloop(self, intro:Optional[str]=...) -> None: ...
    def command_autoimport(self, cmd:List[str]) -> None: ...
    def command_backup(self, cmd:List[str]) -> None: ...
    def command_bail(self, cmd:List[str]) -> None: ...
    def command_color(self, cmd:List[str]) -> None: ...
    def command_colour(self, cmd:List[str]) -> None: ...
    def command_databases(self, cmd:List[str]) -> None: ...
    def command_dump(self, cmd:List[str]) -> None: ...
    def command_echo(self, cmd:List[str]) -> None: ...
    def command_encoding(self, cmd:List[str]) -> None: ...
    def command_exceptions(self, cmd:List[str]) -> None: ...
    def command_exit(self, cmd:List[str]) -> None: ...
    def command_explain(self, cmd:List[str]) -> None: ...
    def command_find(self, cmd:List[str]) -> None: ...
    def command_header(self, cmd:List[str]) -> None: ...
    def command_headers(self, cmd:List[str]) -> None: ...
    def command_help(self, cmd:List[str]) -> None: ...
    def command_import(self, cmd:List[str]) -> None: ...
    def command_indices(self, cmd:List[str]) -> None: ...
    def command_load(self, cmd:List[str]) -> None: ...
    def command_mode(self, cmd:List[str]) -> None: ...
    def command_nullvalue(self, cmd:List[str]) -> None: ...
    def command_open(self, cmd:List[str]) -> None: ...
    def command_output(self, cmd:List[str]) -> None: ...
    def command_print(self, cmd:List[str]) -> None: ...
    def command_prompt(self, cmd:List[str]) -> None: ...
    def command_quit(self, cmd:List[str]) -> None: ...
    def command_read(self, cmd:List[str]) -> None: ...
    def command_restore(self, cmd:List[str]) -> None: ...
    def command_schema(self, cmd:List[str]) -> None: ...
    def command_separator(self, cmd:List[str]) -> None: ...
    def command_show(self, cmd:List[str]) -> None: ...
    def command_tables(self, cmd:List[str]) -> None: ...
    def command_timeout(self, cmd:List[str]) -> None: ...
    def command_timer(self, cmd:List[str]) -> None: ...
    def command_width(self, cmd:List[str]) -> None: ...
    def complete(self, token:str, state:int) -> Optional[List[str]]: ...
    def complete_command(self, line:str, token:str, beg:int, end:int) -> List[str]: ...
    def complete_sql(self, line:str, token:str, beg:int, end:int) -> List[str]:  ...
    def display_timing(self, b4:Dict[str, Union[int, float]], after:Dict[str,
        Union[int, float]]) -> None: ...
    def fixup_backslashes(self, s:str) -> str: ...
    def get_resource_usage(self) -> Dict[str, Union[int, float]]: ...
    def getcompleteline(self) -> Optional[str]: ...
    def getline(self, prompt:str=...) -> Optional[str]: ...
    def handle_exception(self) -> None: ...
    def handle_interrupt(self) -> None: ...
    def output_column(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_columns(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_csv(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_html(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_insert(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_json(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_line(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_lines(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_list(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_python(self, header:Optional[bool], line:List[str]) -> None: ...
    def output_tcl(self, header:Optional[bool], line:List[str]) -> None: ...
    def pop_input(self) -> None: ...
    def pop_output(self) -> None: ...
    def process_args(self, args:List[str]) -> Tuple[str, List[str], List[str]]: ...
    def process_command(self, cmd:str) -> None: ...
    def process_complete_line(self, cmd:str) -> None: ...
    def process_sql(self, sql:str, bindings:Optional[_Bindings]=...,
            internal:bool=..., summary:Optional[Tuple[str, str]]=...) -> None: ...
    def process_unknown_args(self, args:List[str]) -> Optional[List[str]]: ...
    def push_input(self) -> None: ...
    def push_output(self) -> None: ...
    def set_encoding(self, enc:str) -> None: ...
    def usage(self) -> str: ...
    def write(self, dest:TextIO, text:str) -> None: ...
    @property
    def db(self) -> Connection: ...
    @db.setter
    def db(self, newv:Tuple[Connection, str]) -> None: ...

class ThreadingViolationError(Error): ...

class TooBigError(Error): ...

class URIFilename:
    def filename(self, *args, **kwargs) -> Any: ...
    def uri_boolean(self, *args, **kwargs) -> Any: ...
    def uri_int(self, *args, **kwargs) -> Any: ...
    def uri_parameter(self, *args, **kwargs) -> Any: ...

class VFS:
    def __init__(self, *args, **kwargs) -> None: ...
    def excepthook(self, *args, **kwargs) -> Any: ...
    def unregister(self, *args, **kwargs) -> Any: ...
    def xAccess(self, *args, **kwargs) -> Any: ...
    def xCurrentTime(self, *args, **kwargs) -> Any: ...
    def xDelete(self, *args, **kwargs) -> Any: ...
    def xDlClose(self, *args, **kwargs) -> Any: ...
    def xDlError(self, *args, **kwargs) -> Any: ...
    def xDlOpen(self, *args, **kwargs) -> Any: ...
    def xDlSym(self, *args, **kwargs) -> Any: ...
    def xFullPathname(self, *args, **kwargs) -> Any: ...
    def xGetLastError(self, *args, **kwargs) -> Any: ...
    def xGetSystemCall(self, *args, **kwargs) -> Any: ...
    def xNextSystemCall(self, *args, **kwargs) -> Any: ...
    def xOpen(self, *args, **kwargs) -> Any: ...
    def xRandomness(self, *args, **kwargs) -> Any: ...
    def xSetSystemCall(self, *args, **kwargs) -> Any: ...
    def xSleep(self, *args, **kwargs) -> Any: ...

class VFSFile:
    def __init__(self, *args, **kwargs) -> None: ...
    def excepthook(self, *args, **kwargs) -> Any: ...
    def xCheckReservedLock(self, *args, **kwargs) -> Any: ...
    def xClose(self, *args, **kwargs) -> Any: ...
    def xDeviceCharacteristics(self, *args, **kwargs) -> Any: ...
    def xFileControl(self, *args, **kwargs) -> Any: ...
    def xFileSize(self, *args, **kwargs) -> Any: ...
    def xLock(self, *args, **kwargs) -> Any: ...
    def xRead(self, *args, **kwargs) -> Any: ...
    def xSectorSize(self, *args, **kwargs) -> Any: ...
    def xSync(self, *args, **kwargs) -> Any: ...
    def xTruncate(self, *args, **kwargs) -> Any: ...
    def xUnlock(self, *args, **kwargs) -> Any: ...
    def xWrite(self, *args, **kwargs) -> Any: ...

class VFSFileClosedError(Error): ...

class VFSNotImplementedError(Error): ...

class zeroblob:
    def __init__(self, size:int) -> None: ...
    def length(self) -> int: ...

# not exposed
class blob:
    def __enter__(self) -> blob: ...
    def __exit__(self, type:Optional[Type[BaseException]],
            value:Optional[BaseException], traceback:Any) -> bool: ...
    def close(self, force:bool=...) -> None: ...
    def length(self) -> int: ...
    def read(self, nbytes:int=...) -> bytes: ...
    def readinto(self, buf:_WriteableBuffer, offset:int=..., length:int=...) -> None: ...
    def reopen(self, rowid:int) -> None: ...
    def seek(self, offset:int, whence:int=...) -> None: ...
    def tell(self) -> int: ...
    def write(self, data:_ReadableBuffer) -> None: ...

# not exposed
class backup:
    def __enter__(self) -> backup: ...
    def __exit__(self, type:Optional[Type[BaseException]],
            value:Optional[BaseException], traceback:Any) -> bool: ...
    def close(self, force:bool=...) -> None: ...
    done: bool
    def finish(self) -> None: ...
    pagecount: int
    remaining: int
    def step(self, npages:int=...) -> bool: ...
